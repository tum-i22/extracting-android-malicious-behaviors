#!/usr/bin/python

import handleJsonFile as jsonf
import handleOS as system
import handleData as hdata
import random

def generate(prob, maliciousBehavior, pathToData, pathToBenignData):
	"""
	Generate repackaged malware by inserting a malicious behavior with a insertion probability
	:param prob: with this probability the malicious behavior is inserted into the benign traces
	:param maliciousBehavior: number of the malicious behavior that is inserted during the generation of repackaged traces
	:param pathToData: path to the folder containing the data folders and the file 'definedMalicious.txt' as well as the dictionary
	:param pathToBenignData: path to the folder, in which the benign traces are located that will be used for generating repackage malware
	:type prob: float
	:type maliciousBehavior: int
	:type pathToData: string
	:type pathToBenignData: string
	:return: path to the folder, in which the generated traces are stored
	:rtype: string
	:example:

	generateRepackagedMalware.generate(0.1, 1, '../../input_data/', '../../input_data/google_play_test/')
	"""
	outputPath = pathToData+'generatedMalware_'+str(prob)+'/malBehavior_'+str(maliciousBehavior)+'/'
	emptyOutputFolder(outputPath)	
	# load the malicious behavior that is displayed by the numerical parameter 'maliciousBehavior'
	allMaliciousData = hdata.getDefinedMaliciousBehavior(pathToData)
	malCalls = allMaliciousData[maliciousBehavior-1]
	# fetch the benign traces and insert the malicous behavior with the insertion probability 'prob'
	getBenignFilesAndInsert(prob, maliciousBehavior, malCalls, pathToBenignData, outputPath)
	return outputPath

def emptyOutputFolder(outputPath):
	if system.exists(outputPath):
		system.deleteAllFilesInFolder(outputPath)
	else:
		system.createOutputFolder(outputPath)

def getBenignFilesAndInsert(prob, maliciousBehavior, malCalls, pathToFolder, outputPath):
	numberOfFiles = jsonf.getNumberOfFilesInFolder(pathToFolder)
	amount = 10
	# load benign traces in packages of 10 in order to ensure a smooth execution
	for i in range(0, (numberOfFiles/amount)+1):
		benignFiles, names = jsonf.getAmountOfFilesInFolder(pathToFolder, i*amount, amount)
		insertIntoBenignFiles(benignFiles, malCalls, prob, maliciousBehavior, outputPath)
		
def insertIntoBenignFiles(benignFiles, malCalls, prob, maliciousBehavior, outputPath):
	# for each benign file insert malicious calls from the malicious behavior with the probability 'prob'
	for i in range(0, len(benignFiles)):
		singleBenignFile = benignFiles[i]
		newData = insertCalls(singleBenignFile, malCalls, prob)
    		writeToFile(outputPath, newData, prob, maliciousBehavior)

def insertCalls(benignData, maliciousBehavior, prob):
   	newData = {'calls': []}
    	callId = 0
    	for i in range(len(benignData['calls'])):
        	benignElement = benignData['calls'][i]
		# check if the malicious behavior is inserted and update the current id of the calls of the newly generated traces
        	newData, callId = checkProbabilityAndInsert(prob, benignElement, maliciousBehavior, newData, callId)
    	return newData

def checkProbabilityAndInsert(prob, benignElement, maliciousBehavior, newData, callId):
	"""
	Check if the malicious behavior is inserted regarding the insertion probability
	:param prob: with this probability the malicious behavior is inserted into the benign traces
	:param benignElement: current call of the regarded benign trace
	:param maliciousBehavior: list of the method names of the malicious behavior that is inserted
	:param newData: trace that is currently created during the generation process of repackaged malware
	:param callId: current id of the last call within the resulting trace
	:type prob: float
	:type benignElement: dictionary
	:type maliciousBehavior: list
	:type newData: dictionary
	:type callId: int
	:return: resulting trace after the insertion and the id of the last call of the trace
	:rtype: dictionary, int
	"""
    	# if probability is fulfilled, insert the good call and also a malicious block
    	if random.random() < prob:
		newData, callId = insertGoodCall(benignElement, callId, newData)
        	newData, callId = insertMaliciousCalls(maliciousBehavior, callId, newData)
    	# else: just insert the good call into the repackaged trace that is currently generated
    	else:
		newData, callId = insertGoodCall(benignElement, callId, newData)
    	return newData, callId

def insertMaliciousCalls(maliciousBehavior, callId, newData):
	maliciousCalls = []    	
	for i in range(len(maliciousBehavior)):
		newData, callId = appendCall(callId, maliciousBehavior[i], newData)
    	return newData, callId

def insertGoodCall(goodElement, callId, newData):
	method = goodElement['method']
	newData, callId = appendCall(callId, method, newData)
	return newData, callId

def appendCall(callId, method, newData):
	# increse the id of the calls of the trace before inserting a new method
	callId = callId+1
	call = {'callId': (callId), 'method': method}
	newData['calls'].append(call)
	return newData, callId

def writeToFile(outputPath, newData, prob, maliciousBehavior):
	outputFileName = jsonf.writeToGeneratedFile(outputPath, newData)
    	print 'Data was generated with a probability of '+str(prob)+' and inserting malicious behavior '+str(maliciousBehavior)+' in output file '+outputFileName

